\documentclass[12pt,onecolumn]{IEEEtran}
\usepackage{ifpdf}
\usepackage{graphicx}
\usepackage{cite}
\usepackage{listings}
\usepackage{color}
\usepackage{subcaption}
\usepackage{amsmath}
\usepackage{epstopdf}
\usepackage{algorithm2e}
\usepackage{hyperref}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ 
	backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}; should come as last argument
	basicstyle=\footnotesize,        % the size of the fonts that are used for the code
	breakatwhitespace=true,          % sets if automatic breaks should only happen at whitespace
	breaklines=true,                 % sets automatic line breaking
	captionpos=b,                    % sets the caption-position to bottom
	commentstyle=\color{mygreen},    % comment style
	deletekeywords={...},            % if you want to delete keywords from the given language
	escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
	extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
	firstnumber=1,                   % start line enumeration with line 1
	frame=single,                    % adds a frame around the code
	keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
	keywordstyle=\color{blue},       % keyword style
	language=Java,                   % the language of the code
	morekeywords={*,...},            % if you want to add more keywords to the set
	numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
	numbersep=5pt,                   % how far the line-numbers are from the code
	numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
	rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
	showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
	showstringspaces=false,          % underline spaces within strings only
	showtabs=false,                  % show tabs within strings adding particular underscores
	stepnumber=5,                    % the step between two line-numbers. If it's 1, each line will be numbered
	stringstyle=\color{mymauve},     % string literal style
	tabsize=1,	                   % sets default tabsize to 2 spaces
	title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}

\ifpdf
\pdfinfo{
	/Title (Laboratory Work 3: MapReduce with Phoenix++)
	/Author (Anita de Mello Koch (1371116), Nicholas Kastanos (1393410), Brendon Swanepoel (601949))
	/CreationDate (D:201914121726)
	/ModDate (D:201914121726)
	/Subject (Big Data Lab, MapReduce)
	/Keywords (MapReduce, c++, pheonix++)
}
\fi

\begin{document}
	\title{Laboratory Work 3: MapReduce with Phoenix++}
	
	\author{\IEEEauthorblockN{Anita de Mello Koch (1371116), Nicholas Kastanos (1393410), \\Brendon Swanepoel (601949)}\\
		\IEEEauthorblockA{School of Electrical \& Information Engineering, University of the Witwatersrand, Private Bag 3, 2050, Johannesburg, South Africa\\ELEN4020 Data Intensive Computing in Data Science\\15 April 2019}}
	
	\maketitle
	\thispagestyle{empty}
	
	\section{Introduction}
	
	Phoenix is a MapReduce framework for shared memory systems implemented using C, and reimplemented in Phoenix++ for C++. It uses an inheritance-based model, which when the \verb|split()|, \verb|map()|, and \verb|reduce()| functions are overwritten, can implement MapReduce functionality.
	
	Three different algorithms were implemented using Phoenix++: a word-count algorithm which counts the words in the input text; a Top-K algorithm which outputs the top K elements of the word-count; and a reverse index of words in the text. These algorithms were run on three text inputs, and a list of stopwords is supplied to exclude them from the operations.
	
	\section{Results}
	
	A long, medium, and short set of data were used to run the algorithms. \textit{Dracula} by Bram Stoker is used as the short text, as it is $820~KB$ in size. The medium-sized file is \textit{File2ForLab3.txt}, which was supplied for use in these algorithms, and is $1.31~MB$ in size.  The large file of data is a compilation of texts (which can be downloaded from the \href{https://github.com/kozyraki/phoenix}{Phoenix Github page}), and is $100~MB$ in size.
	
	The running times of the MapReduce section of each algorithm can be seen in Table~\ref{tbl:time}.
	
	\begin{table}[h]
		\centering \caption{Running Times in Seconds} \label{tbl:time}
		\begin{tabular}{llll}
			\hline
			Algorithm     & Small Data & Medium Data & Large Data \\ \hline
			Word Count    & 0.0091722  & 0.0113149   & 0.553257   \\
			Top-10        & 0.0092126  & 0.0110157   & 0.549055   \\
			Top-20        & 0.0122066  & 0.0132727   & 0.535806   \\
			Reverse Index & 0.0686829  & 0.0630872   & 3.60311    \\ \hline
		\end{tabular}
	\end{table}

	\section{Algorithm Data Types}
	
	In order to count the number of appearances of a single word, the word-count and top-K algorithms use a key-pair which uses the word as a key, and the number of appearances as the value. By specifying that the \verb|WordCounter| class inherits from the \verb|MapReduceSort| class using a \verb|sum_combiner|, the MapReduce operation sums the values for each unique key during combination, and sorts the list. The mapping function used for these algorithms can be seen in Algorithm~\ref{alg:mapWord}.
	
	The inverted indexing algorithm makes use of different key-value pairs. The word is used as the key, and the line number which the word appeared is used as the key. The inverted indexing algorithm also inherits from the \verb|MapReduceSort| class, but makes use of a \verb|buffer_combiner| to list all of the unique values of line number for each key. The mapping function used for these algorithms can be seen in Algorithm~\ref{alg:mapIndex}.
	
	The split function used in all of the algorithms can be seen in Algorithm~\ref{alg:split}.
	
	\section{Conclusion}
	
	Phoenix++ is can successfully solve MapReduce problems, and has a simple method of utilising the framework. By making use of C++, one is able to manage the memory more closely and increase the performance of the code.
	
	Phoenix++ was sucessfully used to solve the three MapReduce problems, on small, medium, and larger input data.
	
	\clearpage
	\appendices
	\renewcommand\thefigure{\thesection.\arabic{figure}} 
	\renewcommand\theequation{\thesection.\arabic{equation}} 
	\renewcommand\thetable{\thesection.\arabic{table}}
	\renewcommand\thelstlisting{\thesection.\arabic{lstlisting}}
	
	\section{Pseudocode for Word Count}
	\setcounter{figure}{0}  
	\setcounter{equation}{0} 
	\setcounter{table}{0}

	\begin{algorithm}[H]
		\SetAlgoLined
		\SetKwData{Left}{left}\SetKwData{This}{this}\SetKwData{Up}{up}
		\SetKwFunction{Union}{Union}\SetKwFunction{FindCompress}{FindCompress}
		\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
		\Input{Section of text in each bin.}
		\Output{Text separated into single words and count of appearance.}
		\ForEach{character in input}{Change character to lower-case;\\}
		\While{not at end of input}{
			\While{not at end of input \& character is not aphabetic}{
				Increase iterator;\\
			}
			Set beginning of word to iterator;\\
			\While{not at end of input \& (character is alphabetic or apostrophe)}{
				Increase iterator;\\
			}
			\If{not beginning of word}{Output word and count 1;}
		}
	\caption{Map function of the word count and top-K programs.} \label{alg:mapWord}
	\end{algorithm}
\vspace{5mm}
	\begin{algorithm}[H]
		\SetAlgoLined
		\SetKwData{Left}{left}\SetKwData{This}{this}\SetKwData{Up}{up}
		\SetKwFunction{Union}{Union}\SetKwFunction{FindCompress}{FindCompress}
		\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
		\Input{Section of text in each bin.}
		\Output{Text separated into single words and line number.}
		\ForEach{character in input}{Change character to lower-case;\\}
		\While{not at end of input}{
			\While{not at end of input \& character is not aphabetic}{
				Increase iterator;\\
			}
			Set beginning of word to iterator;\\
			\While{not at end of input \& (character is alphabetic or apostrophe)}{
				Increase iterator;\\
			}
			\If{not beginning of word}{Output word and line number;}
		}
		\caption{Map function of the reverse index program.} \label{alg:mapIndex}
	\end{algorithm}
\vspace{5mm}
	\begin{algorithm}[H]
		\SetAlgoLined
		\SetKwData{Left}{left}\SetKwData{This}{this}\SetKwData{Up}{up}
		\SetKwFunction{Union}{Union}\SetKwFunction{FindCompress}{FindCompress}
		\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
		\Input{Chunk which receives the data.}
		\Output{success or failure to allocate data to chunk}
		\If{at end of data}{return 0;\\}
		\While{iterator is less than the chunk size \& not the end of the file}{increase iterator;\\}
		return 1;\\
		\vspace{2mm}
		\caption{Split function for the Phoenix++ programs.}	\label{alg:split}
	\end{algorithm}

	\section{Stopwords}
	\setcounter{figure}{0}  
	\setcounter{equation}{0} 
	\setcounter{table}{0}
	
	\begin{tabular}{|lllllllll|}
		\hline
		a       & below    & from    & how      & most      & over      & them       & we      & won't      \\
		about   & between  & further & how's    & mustn't   & own       & themselves & we'd    & why        \\
		above   & both     & had     & i        & my        & same      & then       & we'll   & why's      \\
		after   & but      & hadn't  & i'd      & myself    & shan't    & there      & we're   & would      \\
		again   & by       & has     & i'll     & needn't   & she       & there's    & we've   & wouldn't   \\
		against & can      & hasn't  & i'm      & no        & she'd     & these      & were    & you        \\
		ain't   & can't    & have    & i've     & nor       & she'll    & they       & weren't & you'd      \\
		all     & could    & haven't & if       & not       & she's     & they'd     & what    & you'll     \\
		am      & couldn't & having  & in       & now       & should    & they're    & what's  & you're     \\
		an      & did      & he      & into     & of        & should've & they've    & when    & you've     \\
		and     & didn't   & he'd    & is       & off       & shouldn't & this       & when's  & your       \\
		any     & do       & he'll   & isn't    & on        & so        & those      & where   & yours      \\
		are     & does     & he's    & it       & once      & some      & through    & where's & yourself   \\
		aren't  & doesn't  & her     & it's     & only      & such      & to         & which   & yourselves \\
		as      & doing    & here    & its      & or        & than      & too        & while   &            \\
		at      & don't    & here's  & itself   & other     & that      & under      & who     &            \\
		be      & down     & hers    & just     & ought     & that'll   & until      & who's   &            \\
		because & during   & herself & let's    & our       & that's    & up         & whom    &            \\
		been    & each     & him     & me       & ours      & the       & very       & why     &            \\
		before  & few      & himself & mightn't & ourselves & their     & was        & will    &            \\
		being   & for      & his     & more     & out       & theirs    & wasn't     & with    &            \\ \hline
	\end{tabular} 
	
	
\end{document}